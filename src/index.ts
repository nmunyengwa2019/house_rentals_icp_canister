import {
    query,
    update,
    Record,
    StableBTreeMap,
    Vec,
    nat64,
    Opt,
    text,
    Canister, 
    bool,   
    blob,
    nat16,
    Principal,
    ic,
    Result,
    Ok,
    Err
  } from "azle";

  import { v4 as uuidv4 } from "uuid";

  
  const House = Record({
    id: text,
    owner_principal:Principal,
    image:blob,
    isBooked:bool,
    rooms:nat16,
    bathrooms:nat16,
    ensuit:bool,
    address:text,
    rating:text
  });

  const HousePayload = Record({
    image:blob,
    isBooked:bool,
    rooms:nat16,
    bathrooms:nat16,
    ensuit:bool,
    address:text,
  });

  const numOfroomsPayload = Record({
    minimumRooms:nat16,
    maximumRooms:nat16
  });

  type House = typeof House;
  type HousePayload = typeof HousePayload;

  let houseStorage = StableBTreeMap<text,House>(text,House,0);


  // Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0
}

function validateHomePayload(payload: HousePayload): Vec<string>{
  const errors: Vec<string> = [];
  if (isInvalidString(payload.address)){
      errors.push(`House address must not be empty. Current house address='${payload.address}'.`)
  }
  if (payload.rooms == 0){
      errors.push(`House must have at least one room. Current rooms='${payload.rooms}'.`)
  }
  if (payload.bathrooms == 0){
      errors.push(`House must have at least one bathroom. Current bathrooms='${payload.bathrooms}'.`)
  }

  return errors;
}
// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}

function isCallerHouseOwnerPrincipal(house: House): boolean {
  return house.owner_principal.toString() === ic.caller().toString(); 
}
  
  export default Canister({

    addHouse: update([HousePayload],Result(House, text),(payload)=>{
      let validatePayloadErrors = validateHomePayload(payload);
      if (validatePayloadErrors.length){
        return Result.Err(`Invalid payload. Errors=[${validatePayloadErrors}]`);
      }
      const house: House={
        id: uuidv4(),
        owner_principal: ic.caller(),
        ...payload,
        rating:"*"
      }
      houseStorage.insert(house.id,house);
      return Ok(house);
    }),
    
    getHouse: query([text], Result(House, text), (id) => {
  // Validate input data
  if (!isValidUuid(id)) {
    // Handle invalid input
    return Err(`Id='${id}' is not in the valid uuid format.`);
  }

  const houseOpt = houseStorage.get(id);

  // Handle house not found
  if ("None" in houseOpt) {
    return Err(`House with id ${id} not found`);
  }

  return Ok(houseOpt.Some);
}),


    getHouses: query([],Vec(House),()=>{

      return houseStorage.values();
    }),

    getUnBookedHouses: query([],Vec(House),()=>{
      const allHouses: House[] = houseStorage.values();
      const unBookedHouses: House[] = [];
      for (const house of allHouses) {
        if (house.isBooked === false) {
          unBookedHouses.push(house);
        }
      }
      return unBookedHouses;
    }),

    getBookedHouses: query([],Vec(House),()=>{
      const allHouses: House[] = houseStorage.values();
      const bookedHouses: House[] = [];
      for (const house of allHouses) {
        if (house.isBooked === true) {
          bookedHouses.push(house);
        }
      }
      return bookedHouses;
    }),

    filterByRooms: query([nat16, nat16], Result(Vec(House), text), (minimumRooms, maximumRooms) => {
  // Validate input data
  if (minimumRooms == 0 || minimumRooms >= maximumRooms) {
    // Handle invalid input
    return Err(`Invalid room range. minimumRooms=${minimumRooms} can't be equal or greater than the maximumRooms=${maximumRooms}`);
  }

  const allHouses: House[] = houseStorage.values();
  const bookedHouses: House[] = [];

  for (const house of allHouses) {
    if (house.isBooked === true && house.rooms >= minimumRooms && house.rooms <= maximumRooms) {
      bookedHouses.push(house);
    }
  }

  return Ok(bookedHouses);
}),



  
    deleteHouse: update([text], Result(House, text), (id) => {
  // Validate input data
  if (!isValidUuid(id)) {
    // Handle invalid input
    return Err(`Id='${id}' is not in the valid uuid format.`);
  }

  
  const houseOpt = houseStorage.get(id);

  // Handle house not found
  if ("None" in houseOpt) {
    return Err(`House with id ${id} not found`);
  }

  const house = houseOpt.Some;
  if (!isCallerHouseOwnerPrincipal(house)){
    return Err("Only the owner's principal of the house can delete the house.")
  }
  houseStorage.remove(id);
  return Ok(house);
}),

  });
  
  // a workaround to make uuid package work with Azle
  globalThis.crypto = {
    // @ts-ignore
   getRandomValues: () => {
       let array = new Uint8Array(32)
  
       for (let i = 0; i < array.length; i++) {
           array[i] = Math.floor(Math.random() * 256)
       }
  
       return array
   }
  }
