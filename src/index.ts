import {
  query,
  update,
  Record,
  StableBTreeMap,
  Vec,
  nat64,
  Opt,
  text,
  Canister,
  bool,
  blob,
  nat16,
  Principal,
  ic,
  Result,
  Ok,
  Err,
} from "azle";

import { v4 as uuidv4 } from "uuid";

const House = Record({
  id: text,
  owner_principal: Principal,
  image: blob,
  isBooked: bool,
  rooms: nat16,
  bathrooms: nat16,
  ensuit: bool,
  address: text,
  rating: text,
});

const HousePayload = Record({
  image: blob,
  isBooked: bool,
  rooms: nat16,
  bathrooms: nat16,
  ensuit: bool,
  address: text,
});

const numOfroomsPayload = Record({
  minimumRooms: nat16,
  maximumRooms: nat16,
});

type House = typeof House;
type HousePayload = typeof HousePayload;
type Text = typeof text;

let houseStorage = StableBTreeMap<Text, House>(text, House, 0);

// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0;
}

function validateHomePayload(payload: HousePayload): Vec<string> {
  const errors: Vec<string> = [];
  if (isInvalidString(payload.address)) {
    errors.push(
      `House address must not be empty. Current house address='${payload.address}'.`
    );
  }
  if (payload.rooms == 0) {
    errors.push(
      `House must have at least one room. Current rooms='${payload.rooms}'.`
    );
  }
  if (payload.bathrooms == 0) {
    errors.push(
      `House must have at least one bathroom. Current bathrooms='${payload.bathrooms}'.`
    );
  }

  return errors;
}
// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
  const regexExp =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}

function isCallerHouseOwnerPrincipal(house: House): boolean {
  return house.owner_principal.toString() === ic.caller().toString();
}

export default Canister({
  addHouse: update([HousePayload], Result(House, text), (payload) => {
    let validatePayloadErrors = validateHomePayload(payload);
    if (validatePayloadErrors.length) {
      return Result.Err(`Invalid payload. Errors=[${validatePayloadErrors}]`);
    }
    const house: House = {
      id: uuidv4(),
      owner_principal: ic.caller(),
      ...payload,
      rating: "*",
    };
    houseStorage.insert(house.id, house);
    return Ok(house);
  }),

  getHouse: query([text], Result(House, text), (id) => {
    // Validate input data
    if (!isValidUuid(id)) {
      // Handle invalid input
      return Err(`Id='${id}' is not in the valid uuid format.`);
    }

    const houseOpt = houseStorage.get(id);

    // Handle house not found
    if ("None" in houseOpt) {
      return Err(`House with id ${id} not found`);
    }

    return Ok(houseOpt.Some);
  }),

  getHouses: query([], Vec(House), () => {
    return houseStorage.values();
  }),

  getUnBookedHouses: query([], Vec(House), () => {
    const allHouses: House[] = houseStorage.values();
    const unBookedHouses: House[] = [];
    for (const house of allHouses) {
      if (house.isBooked === false) {
        unBookedHouses.push(house);
      }
    }
    return unBookedHouses;
  }),

  getBookedHouses: query([], Vec(House), () => {
    const allHouses: House[] = houseStorage.values();
    const bookedHouses: House[] = [];
    for (const house of allHouses) {
      if (house.isBooked === true) {
        bookedHouses.push(house);
      }
    }
    return bookedHouses;
  }),

  filterByRooms: query(
    [nat16, nat16],
    Result(Vec(House), text),
    (minimumRooms, maximumRooms) => {
      // Validate input data
      if (minimumRooms == 0 || minimumRooms >= maximumRooms) {
        // Handle invalid input
        return Err(
          `Invalid room range. minimumRooms=${minimumRooms} can't be equal or greater than the maximumRooms=${maximumRooms}`
        );
      }

      const allHouses: House[] = houseStorage.values();
      const bookedHouses: House[] = [];

      for (const house of allHouses) {
        if (
          house.isBooked === true &&
          house.rooms >= minimumRooms &&
          house.rooms <= maximumRooms
        ) {
          bookedHouses.push(house);
        }
      }

      return Ok(bookedHouses);
    }
  ),

  deleteHouse: update([text], Result(House, text), (id) => {
    // Validate input data
    if (!isValidUuid(id)) {
      // Handle invalid input
      return Err(`Id='${id}' is not in the valid uuid format.`);
    }

    const houseOpt = houseStorage.get(id);

    // Handle house not found
    if ("None" in houseOpt) {
      return Err(`House with id ${id} not found`);
    }

    const house = houseOpt.Some;
    if (!isCallerHouseOwnerPrincipal(house)) {
      return Err(
        "Only the owner's principal of the house can delete the house."
      );
    }
    houseStorage.remove(id);
    return Ok(house);
  }),
});

// a workaround to make uuid package work with Azle
globalThis.crypto = {
  // @ts-ignore
  getRandomValues: () => {
    let array = new Uint8Array(32);

    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(Math.random() * 256);
    }

    return array;
  },
};
